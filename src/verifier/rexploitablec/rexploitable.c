#include "rexploitable.h"

configuration config;

int timeout = 0;
int child_done = 0;

void child_handler(int sig)
{
    child_done = 1;
}

void alarm_handler(int sig)
{
    timeout = 1;
}

static int config_handler(void* user, const char* section, const char* name,
                   const char* value)
{
        configuration* pconfig = (configuration*)user;
        if (MATCH("queue", "port")) {
                pconfig->port = atoi(value);
        } else if (MATCH("queue", "host")) {
                pconfig->host = strdup(value);
        } else if (MATCH("queue", "name")) {
                pconfig->queue_name = strdup(value);
        } else if (MATCH("target", "target")) {
                pconfig->target = strdup(value);
        } else if (MATCH("target", "gdbserver")) {
                pconfig->gdbserver = strdup(value);
        } else if (MATCH("target", "gdbserver_address")) {
                pconfig->gdbserver_address = strdup(value);
        } else if (MATCH("target", "temporary_file_template")) {
                pconfig->temporary_file_template = strdup(value);
        } else if (MATCH("target", "timeout")) {
                pconfig->timeout = atoi(value);
        } else if (MATCH("general", "log_level")) {
                pconfig->log_level = atoi(value);
        } else {
                return 0;
        }
        return 1;
}

void die_on_amqp_error(amqp_rpc_reply_t x, char const *context) {
        switch (x.reply_type) {
        case AMQP_RESPONSE_NORMAL:
                return;

        case AMQP_RESPONSE_NONE:
                fprintf(stderr, "%s: missing RPC reply type!\n", context);
                break;

        case AMQP_RESPONSE_LIBRARY_EXCEPTION:
                fprintf(stderr, "%s: %s\n", context, amqp_error_string2(x.library_error));
                break;

        case AMQP_RESPONSE_SERVER_EXCEPTION:
                switch (x.reply.id) {
                case AMQP_CONNECTION_CLOSE_METHOD: {
                        amqp_connection_close_t *m =
                                (amqp_connection_close_t *)x.reply.decoded;
                        fprintf(stderr, "%s: server connection error %uh, message: %.*s\n",
                                context, m->reply_code, (int)m->reply_text.len,
                                (char *)m->reply_text.bytes);
                        break;
                }
                case AMQP_CHANNEL_CLOSE_METHOD: {
                        amqp_channel_close_t *m = (amqp_channel_close_t *)x.reply.decoded;
                        fprintf(stderr, "%s: server channel error %uh, message: %.*s\n",
                                context, m->reply_code, (int)m->reply_text.len,
                                (char *)m->reply_text.bytes);
                        break;
                }
                default:
                        fprintf(stderr, "%s: unknown server error, method id 0x%08X\n",
                                context, x.reply.id);
                        break;
                }
                break;
        }

        exit(1);
}

void write_job_data_to_file(crash* current_crash){
        char* path = strdup(config.temporary_file_template);

        FILE* out = fopen(path, "w");
        if(out == NULL){
                log_error("could not create file in fixed path. Not writable?");
                exit(1);
        }

        int bytes_written = fwrite(current_crash->decoded_crash, 1, current_crash->decoded_crash_size, out);
        if (bytes_written != current_crash->decoded_crash_size){
                log_error("Failed to write to temporary file. Bytes written: %d", bytes_written);
                exit(1);
        }

        current_crash->crash_path = path;

        log_debug("created temporary file %s", path);
        fclose(out);
}


void exec_crash(crash* tc){
        pid_t pid = fork();

        if (pid == -1) {
                log_error("fork failed");
                exit(1);
        } else if (pid == 0) {
                // in parent
                // TODO more generic
                char** argv = malloc(sizeof (char*) * 4);
                char* gdbserver = strdup(config.gdbserver);
                char* target = strdup(config.target);
                char* gdbserver_address = strdup(config.gdbserver_address);
                argv[0] = gdbserver;
                argv[1] = gdbserver_address;
                argv[2] = target;
                argv[3] = 0;
                log_debug("executing %s %s %s", gdbserver, gdbserver_address, target);

                execv(gdbserver, argv);

                log_error("[child] exec failed");
                free(argv);
                free(gdbserver);
                free(gdbserver_address);
                free(target);

                _exit(1);
        }
        else{
                // in child
                signal(SIGALRM, alarm_handler);
                signal(SIGCHLD, child_handler);

                alarm(config.timeout);  // install an alarm to be fired after TIME_LIMIT
                pause();

                int status;
                int result = waitpid(pid, &status, WNOHANG);

                if (timeout) {
                        log_debug("alarm triggered");

                        if (result == 0) {
                                // child still running, so kill it
                                log_warn("killing child\n");
                                kill(pid, 9);
                                wait(NULL);
                        } else {
                                log_warn("alarm triggered, but child finished normally");
                        }
                } else if (child_done) {
                        log_debug("child finished normally");
                        wait(NULL);
                }
                log_debug("target exited with return code %d", status);
        }
}

void free_crash(crash* tc){
        /* if(remove(tc->crash_path) == -1){ */
        /*   log_error("could not delete test case temporary file %s", tc->crash_path); */
        /*   exit(1); */
        /* } */

        free(tc->decoded_crash);
        free(tc->crash_path);
        free(tc);
}

void do_verification(amqp_connection_state_t* conn){
        log_info("Starting verification...");
        for (;;) {
                amqp_rpc_reply_t res;
                amqp_envelope_t envelope;

                amqp_maybe_release_buffers(*conn);

                res = amqp_consume_message(*conn, &envelope, NULL, 0);

                if (AMQP_RESPONSE_NORMAL != res.reply_type) {
                        break;
                }

                printf("Delivery %u, exchange %.*s routingkey %.*s\n",
                       (unsigned)envelope.delivery_tag, (int)envelope.exchange.len,
                       (char *)envelope.exchange.bytes, (int)envelope.routing_key.len,
                       (char *)envelope.routing_key.bytes);

                crash* current_crash = malloc(sizeof(crash));
                // TODO: compute real size
                current_crash->decoded_crash_size = envelope.message.body.len;
                log_debug("decoded crash size is %d", current_crash->decoded_crash_size);
                current_crash->decoded_crash = b64_decode((char*)envelope.message.body.bytes, envelope.message.body.len);
                if (current_crash->decoded_crash == NULL){
                        log_error("Could not decode message.");
                        exit(1);
                }

                write_job_data_to_file(current_crash);
                exec_crash(current_crash);
                free_crash(current_crash);

                amqp_destroy_envelope(&envelope);
        }


}

int main(int argc, char *argv[argc])
{
        amqp_socket_t *socket = NULL;
        amqp_connection_state_t conn;
        int status;
        amqp_bytes_t queuename;

        if (ini_parse("config.ini", config_handler, &config) < 0) {
                log_error("can not load 'config.ini'");
                return 1;
        }

        log_set_level(config.log_level);

        conn = amqp_new_connection();

        socket = amqp_tcp_socket_new(conn);
        if (!socket) {
                log_error("Failed during socket creation");
                return 1;
        }

        status = amqp_socket_open(socket, config.host, config.port);
        if (status) {
                log_error("opening TCP socket");
                return 1;
        }

        die_on_amqp_error(amqp_login(conn, "/", 0, 131072, 0, AMQP_SASL_METHOD_PLAIN,
                               "guest", "guest"),
                          "Logging in");
        amqp_channel_open(conn, 1);
        die_on_amqp_error(amqp_get_rpc_reply(conn), "Opening channel");

        {
                amqp_queue_declare_ok_t *r = amqp_queue_declare(
                        conn, 1, amqp_empty_bytes, 0, 0, 0, 1, amqp_empty_table);
                die_on_amqp_error(amqp_get_rpc_reply(conn), "Declaring queue");
                queuename = amqp_bytes_malloc_dup(r->queue);
                if (queuename.bytes == NULL) {
                        fprintf(stderr, "Out of memory while copying queue name");
                        return 1;
                }
        }

        amqp_queue_bind(conn, 1, queuename, amqp_cstring_bytes("luckycat"),
                  amqp_cstring_bytes(config.queue_name), amqp_empty_table);
        die_on_amqp_error(amqp_get_rpc_reply(conn), "Binding queue");

        amqp_basic_consume(conn, 1, queuename, amqp_empty_bytes, 0, 1, 0,
                     amqp_empty_table);
        die_on_amqp_error(amqp_get_rpc_reply(conn), "Consuming");

        do_verification(&conn);

        die_on_amqp_error(amqp_channel_close(conn, 1, AMQP_REPLY_SUCCESS),
                    "Closing channel");
        die_on_amqp_error(amqp_connection_close(conn, AMQP_REPLY_SUCCESS),
                    "Closing connection");
        if (amqp_destroy_connection(conn) != AMQP_STATUS_OK){
                log_error("Ending connection");
                return 1;
        }

        return 0;
}
